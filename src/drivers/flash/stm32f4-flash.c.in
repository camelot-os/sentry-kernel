// SPDX-FileCopyrightText: 2023 Ledger SAS
// SPDX-License-Identifier: Apache-2.0

/**
 * \file STM32F3xx and F4xx Flash Interface Controller driver (see ST RM0090 datasheet Table 1, Section 3)
 */

#include <sentry/arch/asm-cortex-m/layout.h>
#include <sentry/io.h>
#include <sentry/bits.h>
#include <sentry/ktypes.h>
#include <bsp/drivers/flash/flash.h>

#include "flash_defs.h"

{%- set flash_controller = dts.get_compatible("st,stm32f4-flash-controller") %}

{#- XXX, This driver handle one, and only one, flash controller #}
{%- if flash_controller is defined and flash_controller[0].status == "okay" %}

#define STM32F4_FLASH_W8_STATE {{ flash_controller[0]["wait-state"] }}UL
#define STM32F4_FLASH_W8_STATE_TIMEOUT 0x100UL

kstatus_t flash_probe(void)
{
    uint32_t acr;
    uint32_t wait_state_status;
    const uint32_t wait_state = (STM32F4_FLASH_W8_STATE << FLASH_ACR_LATENCY_SHIFT) & FLASH_ACR_LATENCY_MASK;
    uint32_t count = 0UL;
    kstatus_t status = K_STATUS_OKAY;

    acr = ioread32(FLASH_BASE_ADDR + FLASH_ACR_REG);
    acr &= ~(FLASH_ACR_LATENCY_MASK);
    acr |= wait_state;
    iowrite32(FLASH_BASE_ADDR + FLASH_ACR_REG, acr);

    do {
        wait_state_status = ioread32(FLASH_BASE_ADDR + FLASH_ACR_REG) & FLASH_ACR_LATENCY_MASK;
        count++;
    } while ((wait_state != wait_state_status) && (count < STM32F4_FLASH_W8_STATE_TIMEOUT));

    if (unlikely(wait_state != wait_state_status)) {
        status = K_ERROR_NOTREADY;
    }

    return status;
}

{%- endif %}
