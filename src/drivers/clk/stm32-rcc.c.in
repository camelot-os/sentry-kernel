// SPDX-FileCopyrightText: 2023 Ledger SAS
// SPDX-License-Identifier: Apache-2.0

/**
 * \file STM32F3xx and F4xx PLL & clock driver (see ST RM0090 datasheet)
 */
#include <assert.h>

#include <sentry/arch/asm-cortex-m/soc.h>
#include <sentry/arch/asm-cortex-m/layout.h>
#include <sentry/arch/asm-cortex-m/core.h>
#include <sentry/arch/asm-cortex-m/buses.h>
#include <sentry/arch/asm-generic/membarriers.h>
#include <sentry/io.h>
#include <sentry/bits.h>
#include <sentry/ktypes.h>
#include <sentry/managers/memory.h>

#include <bsp/drivers/gpio/gpio.h>

/* local includes, only manipulated by the driver itself */
#include <bsp/drivers/clk/rcc.h>

/* RCC generated header for current platform */
#include "stm32-rcc-dt.h"
#include "rcc_defs.h"

#if defined(CONFIG_SOC_SUBFAMILY_STM32F4)
#include "stm32f4-rcc.h"
#elif defined(CONFIG_SOC_SUBFAMILY_STM32L4)
#include "stm32l4-rcc.h"
#endif
#include "stm32-rcc.h"

{%- if dts.clocks.clk_lsi.status == "okay" %}
#define RCC_LSI_FREQUENCY {{ dts.clocks.clk_lsi['clock-frequency'] }}UL
{%- endif %}
{%- if dts.clocks.clk_lse.status == "okay" %}
#define RCC_LSE_FREQUENCY {{ dts.clocks.clk_lse['clock-frequency'] }}UL
{%- endif %}
{%- if dts.clocks.clk_hsi.status == "okay" %}
#define RCC_HSI_FREQUENCY {{ dts.clocks.clk_hsi['clock-frequency'] }}UL
{%- endif %}
/* TODO High Speed External xtal !*/

{%- if dts.clocks.pll.status == "okay" %}
{%- set pll_clock_source = dts.clocks.pll.clocks %}
{%- if pll_clock_source.label != "clk_hsi" and pll_clock_source.label != "clk_hse" %}
#error "invalid PLL ({{ pll_clock_source.label }}) source configuration, check project dts file"
{%- endif %}

static_assert(IN_RANGE(RCC_PLL_VCO_DIVIDER, RCC_PLL_VCO_DIVIDER_RANGE), "VCO divider out of range");
static_assert(IN_RANGE(RCC_PLL_VCO_MULTIPLIER, RCC_PLL_VCO_MULTIPLIER_RANGE), "VCO multiplier out of range");
static_assert(IN_RANGE(RCC_PLL_USB_DIVIDER, RCC_PLL_USB_DIVIDER_RANGE), "invalid pll usb configuration");
static_assert(IN_RANGE(RCC_PLL_SYSCLK_DIVIDER, RCC_PLL_SYSCLK_DIVIDER_RANGE), "Pll main divider out of range");
static_assert((RCC_PLL_SYSCLK_DIVIDER % 2) == 0, "Pll main divider must be even");

{%- set pll_input_freq = pll_clock_source['clock-frequency'] %}
#define RCC_PLL_INPUT_FREQUENCY  {{ pll_input_freq|int }}UL

{%- set pll_vco_input_frequency = pll_input_freq / dts.clocks.pll.vco_divider %}
#define RCC_PLL_VCO_IN_FREQUENCY {{ pll_vco_input_frequency|int }}UL
static_assert(IN_RANGE(RCC_PLL_VCO_IN_FREQUENCY, RCC_PLL_VCO_INPUT_FREQUENCY_RANGE), "VCO IN frequency invalid, check configuration");

{%- set pll_vco_output_frequency = pll_vco_input_frequency * dts.clocks.pll.vco_multiplier %}
#define RCC_PLL_VCO_OUT_FREQUENCY {{ pll_vco_output_frequency|int }}UL
static_assert(IN_RANGE(RCC_PLL_VCO_OUT_FREQUENCY, RCC_PLL_VCO_OUTPUT_FREQUENCY_RANGE), "VCO OUT frequency, check configuration");

#define RCC_PLLCLK_FREQUENCY    {{ (pll_vco_output_frequency / dts.clocks.pll.main_divider)|int }}UL
static_assert(RCC_PLLCLK_FREQUENCY <= RCC_PLL_MAIN_OUTPUT_FREQUENCY_MAX, "PLL output fequency out of range");

#define RCC_PLLUSB_FREQUENCY    {{ (pll_vco_output_frequency / dts.clocks.pll.usb_divider)|int }}UL
static_assert(RCC_PLLUSB_FREQUENCY <= RCC_PLL_USB_OUTPUT_FREQUENCY_MAX, "PLL USB output fequency out of range");
{%- endif %} {#- endif dts.clocks.pll.status == "okay" #}


{%- if dts.rcc.status == "okay" %}
#define RCC_SYSTEM_CLOCK_FREQUENCY {{ dts.rcc["clock-frequency"]|int }}UL
{%- set rcc_clock_source = dts.rcc.clocks %}
{%- for bus_prescaler in dts.rcc['bus-prescalers'] %}
{%- set bus_name = dts.rcc['bus-names'][loop.index - 1].upper() %}
#define RCC_{{ bus_name }}_PRESCALER_POW2 {{ bus_prescaler|int }}UL
#define RCC_{{ bus_name }}_CLOCK_FREQUENCY (RCC_SYSTEM_CLOCK_FREQUENCY >> RCC_{{ bus_name }}_PRESCALER_POW2)
{%- endfor %}

static_assert(IN_RANGE(RCC_AHB_PRESCALER_POW2, RCC_PLL_AHB_PRESCALER_RANGE), "AHB prescaler out of range");
static_assert(RCC_AHB_PRESCALER_POW2 != 5, "32 is an invalid value for STM32xxx AHB prescaler");
static_assert(IN_RANGE(RCC_APB1_PRESCALER_POW2, RCC_PLL_APB_PRESCALER_RANGE), "APB1 prescaler out of range");
static_assert(IN_RANGE(RCC_APB2_PRESCALER_POW2, RCC_PLL_APB_PRESCALER_RANGE), "APB2 prescaler out of range");

static_assert(RCC_SYSTEM_CLOCK_FREQUENCY <= RCC_SYSCLOCK_FREQUENCY_MAX, "System clock out of range");
static_assert(RCC_AHB_CLOCK_FREQUENCY <= RCC_SYSTEM_CLOCK_FREQUENCY, "Invalid RCC AHB clock configuration");
static_assert(RCC_APB1_CLOCK_FREQUENCY <= RCC_APB1_BUS_FREQUENCY_MAX, "Invalid RCC APB1 clock configuration");
static_assert(RCC_APB2_CLOCK_FREQUENCY <= RCC_APB2_BUS_FREQUENCY_MAX, "Invalid RCC APB2 clock configuration");

kstatus_t rcc_map(void)
{
    stm32_rcc_desc_t const * desc = stm32_rcc_get_desc();
    return mgr_mm_map_kdev(desc->base_addr, desc->size);
}
/* for simplicity sake, but unmaping a kernel device is generic */
kstatus_t rcc_unmap(void) {
    return mgr_mm_unmap_kdev();
}

uint32_t rcc_get_core_frequency(void)
{
    return RCC_SYSTEM_CLOCK_FREQUENCY;
}

__STATIC_INLINE kstatus_t rcc_enable_hsi(void)
{
    kstatus_t status = K_STATUS_OKAY;
    uint32_t rcc_cr;
    uint32_t hsi_ready;
    uint32_t count = 0UL;

    rcc_cr = ioread32(RCC_BASE_ADDR + RCC_CR_REG);
    rcc_cr |= RCC_CR_HSION;
    iowrite32(RCC_BASE_ADDR + RCC_CR_REG, rcc_cr);

    do {
        hsi_ready = ioread32(RCC_BASE_ADDR + RCC_CR_REG) & RCC_CR_HSIRDY;
        count++;
    } while ((hsi_ready == 0) && (count < HSI_STARTUP_TIMEOUT));

    if (unlikely(hsi_ready == 0)) {
        status = K_ERROR_NOTREADY;
    }

    return status;
}

/* TODO handle bypass mode for HSE */
__STATIC_INLINE kstatus_t rcc_enable_hse(void)
{
    kstatus_t status = K_STATUS_OKAY;
    uint32_t rcc_cr;
    uint32_t hse_ready = 0;
    uint32_t count = 0UL;

    rcc_cr = ioread32(RCC_BASE_ADDR + RCC_CR_REG);
    rcc_cr |= RCC_CR_HSEON;
    iowrite32(RCC_BASE_ADDR + RCC_CR_REG, rcc_cr);

    do {
        hse_ready = ioread32(RCC_BASE_ADDR + RCC_CR_REG) & RCC_CR_HSERDY;
        count++;
    } while ((hse_ready == 0) && (count < HSE_STARTUP_TIMEOUT));

    if (unlikely(hse_ready == 0)) {
        status = K_ERROR_NOTREADY;
    }

    return status;
}

__STATIC_INLINE uint32_t rcc_ahb_busdiv(void)
{
    uint32_t value;
    if (RCC_AHB_PRESCALER_POW2 == 0) {
        value = 0UL;
    }
    else if (IN_RANGE(RCC_AHB_PRESCALER_POW2, RANGE(1, 4))) {
        value = 0x8 | (RCC_AHB_PRESCALER_POW2 - 1);
    }
    else if (IN_RANGE(RCC_AHB_PRESCALER_POW2, RANGE(6, 9))) {
        value = 0x8 | (RCC_AHB_PRESCALER_POW2 - 2);
    }

    return value;
}

__STATIC_INLINE uint32_t rcc_apb_busdiv(uint32_t div_pow2)
{
    uint32_t value;
    if (div_pow2 == 0) {
        value = 0UL;
    }
    else {
        value = 0x4 | (div_pow2 - 1);
    }

    return value;
}

__STATIC_INLINE kstatus_t rcc_set_bus_clock(void)
{
    union {
        rcc_cfgr_t cfgr;
        uint32_t raw;
    } reg;

    reg.raw = ioread32(RCC_BASE_ADDR + RCC_CFGR_REG);
    reg.cfgr.hpre = rcc_ahb_busdiv();
    reg.cfgr.ppre1 = rcc_apb_busdiv(RCC_APB1_PRESCALER_POW2);
    reg.cfgr.ppre2 = rcc_apb_busdiv(RCC_APB2_PRESCALER_POW2);
    iowrite32(RCC_BASE_ADDR + RCC_CFGR_REG, reg.raw);

    return K_STATUS_OKAY;
}

/**
 * @brief Configures the System clock source, PLL Multiplier and Divider factors,
 * AHB/APBx prescalers and Flash settings
 *
 *
 * This function should be called only once the RCC clock configuration
 * is reset to the default reset state (done in SystemInit(UL) functionUL).
 *
 */
__STATIC_INLINE kstatus_t rcc_init_system_clk(void)
{
    kstatus_t status = K_STATUS_OKAY;

/* TODO LSI enable */
#if 0
    {%- if dts.clocks.clk_lsi.status == "okay" %}
    status = rcc_enable_lsi();
    if (unlikely(status != K_STATUS_OKAY)) {
        goto err;
    }
    {%- endif %}
#endif


/* TODO LSE enable */
#if 0
    {%- if dts.clocks.clk_lse.status == "okay" %}
    status = rcc_enable_lse();
    if (unlikely(status != K_STATUS_OKAY)) {
        goto err;
    }
    {%- endif %}
#endif

    {%- if dts.clocks.clk_hsi.status == "okay" %}
    status = rcc_enable_hsi();
    if (unlikely(status != K_STATUS_OKAY)) {
        goto err;
    }
    {%- endif %}

    {%- if dts.clocks.clk_hse.status == "okay" %}
    status = rcc_enable_hse();
    if (unlikely(status != K_STATUS_OKAY)) {
        goto err;
    }
    {%- endif %}

    /* enables bus prescaler before pll */
    status = rcc_set_bus_clock();
    if (unlikely(status != K_STATUS_OKAY)) {
        goto err;
    }

    {%- if dts.clocks.pll.status == "okay" %}
    status = rcc_enable_pll();
    if (unlikely(status != K_STATUS_OKAY)) {
        goto err;
    }
    {%- endif %}

    status = rcc_select_system_clock();
    if (unlikely(status != K_STATUS_OKAY)) {
        goto err;
    }

#if 0
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    write_reg_value(FLASH_ACR, FLASH_ACR_ICEN
                    | FLASH_ACR_DCEN | FLASH_ACR_LATENCY_5WS);
#endif

err:
    return status;
}


kstatus_t rcc_probe(void)
{
    kstatus_t status;
    size_t reg;
    if (unlikely((status = rcc_map()) != K_STATUS_OKAY)) {
        goto err;
    }
    /* Reset the RCC clock configuration to the default reset state */
    /* Set HSION bit */
    reg = ioread32(RCC_BASE_ADDR + RCC_CR_REG);
    reg |= 0x1UL;
    iowrite32(RCC_BASE_ADDR + RCC_CR_REG, reg);

    /* Reset CFGR register */
    iowrite32(RCC_BASE_ADDR + RCC_CFGR_REG, 0x0UL);

    /* Reset HSEON, CSSON and PLLON bits */
    reg = ioread32(RCC_BASE_ADDR + RCC_CR_REG);
    reg &= ~ (RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON);
    iowrite32(RCC_BASE_ADDR + RCC_CR_REG, reg);

    /* Reset PLLCFGR register, 0x24.00.30.10 being the reset value */
    iowrite32(RCC_BASE_ADDR + RCC_PLLCFGR_REG, 0x24003010UL);

    /* Reset HSEBYP bit */
    reg = ioread32(RCC_BASE_ADDR + RCC_CR_REG);
    reg &= ~(RCC_CR_HSEBYP);
    iowrite32(RCC_BASE_ADDR + RCC_CR_REG, reg);

    /* Reset all interrupts */
    iowrite32(RCC_BASE_ADDR + RCC_CIR_REG, 0x0UL);

    status = rcc_init_system_clk();
    if (unlikely(status != K_STATUS_OKAY)) {
        goto err;
    }
    rcc_unmap();
err:
    return status;
}

/*@
    assigns \nothing;
    ensures \result == K_STATUS_OKAY;
  */
__STATIC_INLINE size_t rcc_get_register(bus_id_t busid, rcc_opts_t flags)
{
    size_t reg_base;
    const size_t lp_offset = 0x20UL; /* RCC regs for LP configuration are shifted by 0x20 */

    if (flags & RCC_LPCONFIG) {
        reg_base = RCC_BASE_ADDR + lp_offset;
    } else {
        reg_base = RCC_BASE_ADDR;
    }

    /*@ assert bus_is_valid(busid); */
    reg_base += busid;

    return reg_base;
}

/**
 * @brief enable given clock identifier for the given bus identifier
 *
 *
 * @param busid bus identifier, generated from SVD file, see buses.h
 * @param clk_msk clock mask, which correspond to the mask to apply on the
 *    bus enable register so that the corresponding device is enabled. This is
 *    a 32bit value that is directly used. On STM32, this value mostly hold a single
 *    bit set to 1 (except for ETH).
 *
 *
 * @return K_STATUS_OKAY of the clock is properly enabled, or an error
 *  status otherwise
 */
/*@
    assigns *(uint32_t*)((RCC_BASE_ADDR + RCC_AHB1ENR_REG) .. (RCC_BASE_ADDR + RCC_APB2ENR_REG));
    ensures \result == K_STATUS_OKAY;
 */
kstatus_t rcc_enable(bus_id_t busid, uint32_t clk_msk, rcc_opts_t flags)
{
    kstatus_t status = K_STATUS_OKAY;
    size_t reg;
    if (unlikely((status = rcc_map()) != K_STATUS_OKAY)) {
        goto err;
    }
    /*@ assert bus_is_valid(busid); */
    size_t reg_base = rcc_get_register(busid, flags);

    reg = ioread32(reg_base);
    reg |= clk_msk;
    iowrite32(reg_base, reg);
    // Stall the pipeline to work around erratum 2.1.13 (DM00037591)
    arch_data_sync_barrier();
    rcc_unmap();
err:
    return status;
}

/**
 * @brief disable given clock identifier for the given bus identifier
 *
 *
 * @param busid bus identifier, generated from SVD file, see buses.h
 * @param clk_msk clock mask, which correspond to the mask to apply on the
 *    bus enable register so that the corresponding device is enabled. This is
 *    a 32bit value that is directly used. On STM32, this value mostly hold a single
 *    bit set to 1 (except for ETH).
 *
 * @return K_STATUS_OKAY of the clock is properly disabled, or an error
 *  status otherwise
 */
/*@
    assigns *(uint32_t*)((RCC_BASE_ADDR + RCC_AHB1ENR_REG) .. (RCC_BASE_ADDR + RCC_APB2ENR_REG));
    ensures \result == K_STATUS_OKAY;
 */
kstatus_t rcc_disable(bus_id_t busid, uint32_t clk_msk, rcc_opts_t flags)
{
    kstatus_t status = K_STATUS_OKAY;
    size_t reg;
    if (unlikely((status = rcc_map()) != K_STATUS_OKAY)) {
        goto err;
    }
    /*@ assert bus_is_valid(busid); */
    size_t reg_base = rcc_get_register(busid, flags);

    reg = ioread32(reg_base);
    reg &= ~clk_msk;
    iowrite32(reg_base, reg);
    rcc_unmap();
err:
    return status;
}

__STATIC_INLINE uint32_t rcc_pre2div(uint32_t pre)
{
    uint32_t div;

    if ((pre & 0x4) == 0) {
        div = 1;
    }
    else {
        div = ((pre & 0x3) + 1) << 1;
    }

    return div;
}

kstatus_t rcc_get_bus_clock(bus_id_t busid, uint32_t *busclk)
{
    kstatus_t status = K_ERROR_INVPARAM;
    size_t reg;
    uint32_t pre;
    uint32_t ahb_div;

    /*
     * XXX:
     * Div is initialized in order to shut down a gcc `maybe-uninitialized` warning.
     * This is a false positive as framaC check this (see contract annotation) but
     * it make sense to initialize it to its minimal value anyways.
     * Thus the case for AHBx busses is empty.
     */
    uint32_t div = 1UL;

    if (unlikely(busclk == NULL)) {
        goto err;
    }
    if (unlikely((status = rcc_map()) != K_STATUS_OKAY)) {
        goto err;
    }
    /*
     * bus clock -->
     *  - AHB_CLK = SYS_CLK / HPRE
     *  - APB1_CLK = AHB_CLK / PPRE1
     *  - APB2_CLK = AHB_CLK / PPRE2
     */
    reg = ioread32(RCC_BASE_ADDR + RCC_CFGR_REG);

    ahb_div = rcc_pre2div((reg & RCC_CFGR_HPRE_MASK) >> RCC_CFGR_HPRE_SHIFT);

    /*@ assert \valid(busclk); */
    /*@ assert bus_is_valid(busid); */
    switch (busid) {
        case BUS_APB1:
            div = rcc_pre2div((reg & RCC_CFGR_PPRE1_MASK) >> RCC_CFGR_PPRE1_SHIFT);
            break;
        case BUS_APB2:
            div = rcc_pre2div((reg & RCC_CFGR_PPRE2_MASK) >> RCC_CFGR_PPRE2_SHIFT);
            break;
        case BUS_AHB1:
        case BUS_AHB2:
#ifndef CONFIG_ARCH_MCU_STM32F401
        case BUS_AHB3:
#endif
            break;
        default:
            /* smoke testing: unreachable code */
            /*@ assert \false; */
            break;

    }
    /* return current bus clock */
    *busclk = ((RCC_SYSTEM_CLOCK_FREQUENCY / ahb_div) / div);
    status = rcc_unmap();
err:
    return status;
}

{%- endif %} /* rcc status okay*/
