// SPDX-FileCopyrightText: 2023 Ledger SAS
// SPDX-License-Identifier: Apache-2.0

/**
 * \file STM32L4xx specific RCC implementation
 */
#include <assert.h>

#include <sentry/arch/asm-cortex-m/soc.h>
#include <sentry/arch/asm-cortex-m/layout.h>
#include <sentry/arch/asm-cortex-m/core.h>
#include <sentry/arch/asm-cortex-m/buses.h>
#include <sentry/arch/asm-generic/membarriers.h>
#include <sentry/io.h>
#include <sentry/bits.h>
#include <sentry/ktypes.h>

#include <bsp/drivers/gpio/gpio.h>

/* local includes, only manipulated by the driver itself */
#include <bsp/drivers/clk/rcc.h>

/* RCC generated header for current platform */
#include "stm32-gpio-dt.h"
#include "rcc_defs.h"
#include "stm32l4-rcc.h"
#include "stm32-rcc.h"

{%- set rcc_clock_source = dts.rcc.clocks %}

kstatus_t rcc_select_system_clock(void)
{
    uint32_t rcc_cfgr;
    uint32_t clocksource;
    uint32_t clocksource_status;
    uint32_t count = 0UL;
    kstatus_t status = K_STATUS_OKAY;

    rcc_cfgr = ioread32(RCC_BASE_ADDR + RCC_CFGR_REG);

    /* previously clear corresponding bits */
    rcc_cfgr &= ~(RCC_CFGR_SW_MASK);

    {%- if rcc_clock_source.label == 'clk_msi' %}
    clocksource = 0UL;
    {%- elif rcc_clock_source.label == 'clk_hsi' %}
    clocksource = 0xb01UL;
    {%- elif rcc_clock_source.label == 'clk_hse' %}
    clocksource = 0xb10UL;
    {%- elif rcc_clock_source.label == 'pll' %}
    clocksource = 0xb11UL;
    {%- else %}
    #error "clock source configuration error, please check your devicetree file"
    {%- endif %}

    rcc_cfgr |= clocksource;
    iowrite32(RCC_BASE_ADDR + RCC_CFGR_REG, rcc_cfgr);

    /* clocksource status is shifted by 2 on the same register */
    clocksource = clocksource << 2UL;
    do {
        clocksource_status = ioread32(RCC_BASE_ADDR + RCC_CFGR_REG) & clocksource;
        count++;
    } while ((clocksource_status != clocksource) && (count < PLL_STARTUP_TIMEOUT)); /* XXX: same timeout as PLL ?! */

    if (clocksource_status != clocksource) {
        status = K_ERROR_NOTREADY;
    }

    return status;
}

kstatus_t rcc_enable_pll(void)
{
    uint32_t pllcfgr;
    uint32_t pll_ready;
    uint32_t rcc_cr;
    uint32_t count = 0UL;
    kstatus_t status = K_STATUS_OKAY;

    /*
     * XXX:
     *  SVD generation is not our friend here !
     *  PLL coefficients are split into single bit definition (...)
     */

    pllcfgr = rcc_pll_p_divider()
            | rcc_pll_m_divider()
            | rcc_pll_n_multiplier()
            | rcc_pll_q_divider();

    pllcfgr &= ~(RCC_PLLCFGR_PLLSRC_MASK);
    {%- if pll_clock_source == "clk_msi" %}
    /* msi as pll source */
    pllcfgr |= (0b01UL << RCC_PLLCFGR_PLLSRC_SHIFT) & RCC_PLLCFGR_PLLSRC_MASK;
    {%- elif pll_clock_source == "clk_hsi" %}
    /* hsi16 as pll source */
    pllcfgr |= (0b10UL << RCC_PLLCFGR_PLLSRC_SHIFT) & RCC_PLLCFGR_PLLSRC_MASK;
    {%- else %}
    /* hse as pll source */
    pllcfgr |= (0b11UL << RCC_PLLCFGR_PLLSRC_SHIFT) & RCC_PLLCFGR_PLLSRC_MASK;
    {%- endif %}

    /* write pll configuration */
    iowrite32(RCC_BASE_ADDR + RCC_PLLCFGR_REG, pllcfgr);

    /* then, enable pll */
    rcc_cr = ioread32(RCC_BASE_ADDR + RCC_CR_REG);
    rcc_cr |= RCC_CR_PLLON;
    iowrite32(RCC_BASE_ADDR + RCC_CR_REG, rcc_cr);
    /* Wait till the main PLL is ready */
    do {
        pll_ready = ioread32(RCC_BASE_ADDR + RCC_CR_REG) & RCC_CR_PLLRDY;
        count++;
    } while ((pll_ready == 0) && (count < PLL_STARTUP_TIMEOUT));

    if (pll_ready == 0) {
        status = K_ERROR_NOTREADY;
    }

    return status;
}

#if CONFIG_BUILD_TARGET_DEBUG
kstatus_t rcc_enable_debug_clockout(void)
{
    kstatus_t status = K_STATUS_OKAY;
    uint32_t prescaler;
    uint32_t rcc_cfgr;

    {%- set mco_clk_in = [
        ({"clk_hsi": 0x03, "clk_lse": 0x07, "clk_hse": 0x04, "pll": 0x5}),
    ] %}

    {%- set mcos = [dts.rcc.mco] %}
    {%- for mco in mcos %}
    {%- if mco is defined and mco.status == "okay" %}
    {%- set mco_name = mco.name.upper() %}
    /* Configuring {{ mco_name }} */
    prescaler = {{ mco.prescaler }};
    rcc_cfgr = ioread32(RCC_BASE_ADDR + RCC_CFGR_REG);

    if (prescaler > 0) {
        prescaler--;
    }
    /*
     * XXX:
     *  Documentation said:
     *    Set and cleared by software to configure the prescaler of the MCO1/2. Modification of this
     *    prescaler may generate glitches on MCO1/2. It is highly recommended to change this
     *    prescaler only after reset before enabling the external oscillators and the PLLs.
     *
     * As we use these as clock debugging feature and **not** for clock sharing with other device(s)
     * we do not care about any glitches on mco lines.
     */
    rcc_cfgr &= ~(RCC_CFGR_{{ mco_name }}_MASK | RCC_CFGR_{{ mco_name }}PRE_MASK);
    rcc_cfgr |= (prescaler << RCC_CFGR_{{ mco_name }}PRE_SHIFT) & RCC_CFGR_{{ mco_name }}PRE_MASK;
    rcc_cfgr |= ({{ mco_clk_in[loop.index - 1][mco.clockout.label] }} << RCC_CFGR_{{ mco_name }}_SHIFT) & RCC_CFGR_{{ mco_name }}_MASK;

    iowrite32(RCC_BASE_ADDR + RCC_CFGR_REG, rcc_cfgr);

    {%- set pinctrl = mco["pinctrl-0"] %}
    {%- set port, pin, mode, altfunc = pinctrl.pinmux %}
    {%- set type, speed, pull_mode = pinctrl.pincfg %}

    gpio_set_mode({{ port.label.upper() }}_PORT_ID, {{ pin }}, {{ mode }});
    gpio_set_type({{ port.label.upper() }}_PORT_ID, {{ pin }}, {{ type }});
    gpio_set_speed({{ port.label.upper() }}_PORT_ID, {{ pin }}, {{ speed }});
    gpio_set_pull_mode({{ port.label.upper() }}_PORT_ID, {{ pin }}, {{ pull_mode }});
    gpio_set_af({{ port.label.upper() }}_PORT_ID, {{ pin }}, {{ altfunc }});

    {%- endif%}
    {%- endfor %}

    return status;
}
#endif
